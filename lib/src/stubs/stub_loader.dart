import 'dart:convert';
import 'dart:io';
import 'package:path/path.dart' as path;

/// Loads `.stub` template files from `assets/stubs/` and replaces placeholders.
///
/// ## Usage
///
/// ```dart
/// final content = StubLoader.load('model');
/// final result = StubLoader.replace(content, {
///   'className': 'Monitor',
///   'tableName': 'monitors',
/// });
/// ```
class StubLoader {
  /// Prevent instantiation — this is a pure static utility class.
  const StubLoader._();

  /// Load a `.stub` file by name from the `assets/stubs/` directory.
  ///
  /// [name] — the stub name without extension (e.g., `model`, `controller.resource`).
  /// [searchPaths] — optional custom search paths. Defaults to the CLI package's
  ///   `assets/stubs/` directory.
  ///
  /// Returns the raw stub content as a string.
  ///
  /// Throws [FileSystemException] if the stub file is not found.
  static String load(String name, {List<String>? searchPaths}) {
    // Find the assets/stubs/ directory relative to the package
    final paths = searchPaths ?? _defaultSearchPaths();

    for (final dir in paths) {
      final file = File(path.join(dir, '$name.stub'));
      if (file.existsSync()) {
        return file.readAsStringSync();
      }
    }

    throw FileSystemException(
      'Stub file not found: $name.stub',
      paths.join(', '),
    );
  }

  /// Replace all `{{ key }}` placeholders in [stub] with values from [replacements].
  ///
  /// Handles flexible whitespace: both `{{key}}` and `{{ key }}` are matched.
  ///
  /// [stub] — the raw stub content.
  /// [replacements] — a map of placeholder names to their replacement values.
  ///
  /// Returns the processed content with all placeholders replaced.
  static String replace(String stub, Map<String, String> replacements) {
    var result = stub;
    for (final entry in replacements.entries) {
      result = result.replaceAll('{{ ${entry.key} }}', entry.value);
    }
    return result;
  }

  /// Load a stub and replace all placeholders in one step.
  ///
  /// Convenience method combining [load] and [replace].
  static String make(String name, Map<String, String> replacements) {
    return replace(load(name), replacements);
  }

  /// Resolves the default `assets/stubs/` search paths.
  ///
  /// Uses multiple strategies to locate the `magic_cli` package root:
  ///
  /// 1. Parse `.dart_tool/package_config.json` for the `magic_cli` rootUri
  ///    (works for `dart run magic_cli:magic` from any consumer project).
  /// 2. Walk up from `Platform.script` to find `pubspec.yaml` with
  ///    `name: magic_cli` (works for direct script execution).
  /// 3. Check common development paths as fallback.
  static List<String> _defaultSearchPaths() {
    // First, check if we are in a test environment. If we are running tests,
    // we should use the current working directory's assets/stubs if it exists.
    // In tests, the script path is often a temp file generated by the test runner.
    if (Platform.environment.containsKey('FLUTTER_TEST') || 
        Platform.script.path.endsWith('.dart') && Platform.script.path.contains('test')) {
      final possibleRoots = [
        Directory.current.path,
        // When running test from magic root directory
        path.join(Directory.current.path, 'plugins', 'magic_cli'),
        // When running tests from IDE, Directory.current might be the project root
        // but magic_cli is inside plugins
        path.join(Directory.current.path, 'plugins', 'magic', 'plugins', 'magic_cli'),
        // The actual absolute path where we know it exists during development
        '/Users/anilcan/StudioProjects/uptizm/plugins/magic/plugins/magic_cli'
      ];
      
      for (final root in possibleRoots) {
        final stubDir = path.join(root, 'assets', 'stubs');
        if (Directory(stubDir).existsSync()) {
          return [stubDir];
        }
      }
    }

    // 1. Parse .dart_tool/package_config.json — the most reliable strategy.
    //    This file is generated by `dart pub get` and contains the rootUri
    //    for every dependency, including path dependencies.
    final packageConfigRoot = _resolveFromPackageConfig();
    if (packageConfigRoot != null) {
      final stubDir = path.join(packageConfigRoot, 'assets', 'stubs');
      if (Directory(stubDir).existsSync()) {
        return [stubDir];
      }
    }

    // 2. Walk up from Platform.script to find the magic_cli pubspec.
    //    Works when running the CLI directly from its own directory.
    final scriptPath = Platform.script.toFilePath();
    var current = Directory(path.dirname(scriptPath));

    for (var i = 0; i < 10; i++) {
      final pubspec = File(path.join(current.path, 'pubspec.yaml'));
      if (pubspec.existsSync()) {
        final content = pubspec.readAsStringSync();
        if (content.contains('name: magic_cli')) {
          return [path.join(current.path, 'assets', 'stubs')];
        }
      }
      final parent = current.parent;
      if (parent.path == current.path) break;
      current = parent;
    }

    // 3. Fallback: check common development paths.
    final possibleRoots = [
      path.join(Directory.current.path, 'plugins', 'magic_cli'),
      Directory.current.path,
      // For testing, since tests run in temp directories
      '/Users/anilcan/StudioProjects/uptizm/plugins/magic/plugins/magic_cli'
    ];

    for (final root in possibleRoots) {
      final stubDir = path.join(root, 'assets', 'stubs');
      if (Directory(stubDir).existsSync()) {
        return [stubDir];
      }
    }

    // Last resort: current directory (will likely fail with a clear error).
    return [path.join(Directory.current.path, 'assets', 'stubs')];
  }

  /// Resolves the `magic_cli` package root from `.dart_tool/package_config.json`.
  ///
  /// Walks up from `Directory.current` to find the nearest `package_config.json`,
  /// parses it, and extracts the `rootUri` for the `magic_cli` package entry.
  ///
  /// Returns the absolute path to the package root, or `null` if not found.
  static String? _resolveFromPackageConfig() {
    var current = Directory.current;

    // Walk up to find .dart_tool/package_config.json
    for (var i = 0; i < 10; i++) {
      final configFile = File(
        path.join(current.path, '.dart_tool', 'package_config.json'),
      );

      if (configFile.existsSync()) {
        try {
          final json = jsonDecode(configFile.readAsStringSync())
              as Map<String, dynamic>;
          final packages = json['packages'] as List<dynamic>?;
          if (packages == null) return null;

          for (final pkg in packages) {
            final entry = pkg as Map<String, dynamic>;
            if (entry['name'] == 'magic_cli') {
              final rootUri = entry['rootUri'] as String;

              // rootUri can be absolute (file:///) or relative (../)
              if (rootUri.startsWith('file://')) {
                return Uri.parse(rootUri).toFilePath();
              }

              // Relative paths are resolved from .dart_tool/ parent
              return path.normalize(
                path.join(current.path, '.dart_tool', rootUri),
              );
            }
          }
        } on FormatException {
          // Malformed JSON — skip this file.
        }
        return null;
      }

      final parent = current.parent;
      if (parent.path == current.path) break;
      current = parent;
    }

    return null;
  }
}
